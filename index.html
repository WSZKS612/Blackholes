<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spacetime Funnel (Interactive)</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0;
      height:100vh;
      display:grid;
      grid-template-rows:auto 1fr;
      background:#061021;
      color:#eaf2ff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    header{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      background:rgba(15,22,40,0.85);
      border-bottom:1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
    }
    .group{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .btn{
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      color:inherit;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{ background:rgba(255,255,255,0.10); }
    .btn.active{
      background:rgba(130,200,255,0.16);
      border-color:rgba(130,200,255,0.35);
    }
    label{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.05);
    }
    input[type="range"]{ width:180px; }
    .hint{ opacity:0.85; font-size:0.92rem; }
    canvas{ width:100%; height:100%; display:block; }
    .badge{
      font-size:12px;
      padding:3px 8px;
      border-radius:999px;
      background:rgba(123,190,255,0.14);
      border:1px solid rgba(123,190,255,0.25);
      color:#cfe8ff;
    }
  </style>
</head>
<body>
  <header>
    <div class="group">
      <span class="badge">Drag the mass • Use slider to change mass • Scroll to zoom</span>
      <span class="badge" id="softBadge" title="Fixed softening (prevents infinite spike at the center)"></span>
    </div>

    <div class="group" id="presets">
      <button class="btn" data-m="1.2" data-name="Sun">Sun</button>
      <button class="btn" data-m="4.0" data-name="Neutron star">Neutron star</button>
      <button class="btn" data-m="12.0" data-name="Black hole">Black hole</button>
    </div>

    <div class="group">
      <label title="Bigger mass = deeper funnel">
        Mass
        <input id="mass" type="range" min="0.2" max="20" step="0.01" value="1.2" />
        <span id="massVal"></span>
      </label>

      <label title="Overall funnel depth (visual scale)">
        Depth
        <input id="depth" type="range" min="150" max="2200" step="1" value="700" />
        <span id="depthVal"></span>
      </label>

      <label title="Grid spacing">
        Grid
        <input id="spacing" type="range" min="16" max="70" step="1" value="34" />
        <span id="spacingVal"></span>
      </label>
    </div>

    <div class="hint" id="titleHint">Preset: Sun</div>
  </header>

  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    // HiDPI
    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const r = canvas.getBoundingClientRect();
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resize);
    resize();

    // UI
    const massEl = document.getElementById("mass");
    const depthEl = document.getElementById("depth");
    const spacingEl = document.getElementById("spacing");
    const massVal = document.getElementById("massVal");
    const depthVal = document.getElementById("depthVal");
    const spacingVal = document.getElementById("spacingVal");
    const titleHint = document.getElementById("titleHint");
    const softBadge = document.getElementById("softBadge");

    // Fixed softening value (world units). Increase to make the center less sharp.
    const SOFTENING = 0.18;
    softBadge.textContent = `Softening: ${SOFTENING}`;

    function updateLabels(){
      massVal.textContent = (+massEl.value).toFixed(2);
      depthVal.textContent = depthEl.value;
      spacingVal.textContent = spacingEl.value + "px";
    }
    [massEl, depthEl, spacingEl].forEach(el => el.addEventListener("input", () => {
      clearPresetActive();
      titleHint.textContent = "Custom mass";
      updateLabels();
    }));
    updateLabels();

    // Presets
    const presetBtns = [...document.querySelectorAll("#presets .btn")];
    function clearPresetActive(){ presetBtns.forEach(b => b.classList.remove("active")); }
    function setPreset(btn){
      clearPresetActive();
      btn.classList.add("active");
      massEl.value = btn.dataset.m;
      titleHint.textContent = `Preset: ${btn.dataset.name}`;
      updateLabels();
    }
    presetBtns.forEach(btn => btn.addEventListener("click", () => setPreset(btn)));
    setPreset(presetBtns[0]);

    // Mass point (draggable)
    const mass = { sx: 0, sy: 0 };
    function centerMass(){
      mass.sx = canvas.clientWidth * 0.25;
      mass.sy = canvas.clientHeight * 0.30;
    }
    centerMass();

    // Camera: oriented like the reference image (no sideways slant)
    // yaw=0 => symmetric, not rotated to the side; pitch tilts down to show depth.
    const cam = {
      yaw: 0.0,
      pitch: 1.08,
      dist: 860,
      zoom: 1.0
    };

    // Wheel zoom
    canvas.addEventListener("wheel", (ev) => {
      ev.preventDefault();
      const dir = Math.sign(ev.deltaY);
      cam.zoom *= (dir > 0) ? 0.92 : 1.08;
      cam.zoom = Math.max(0.55, Math.min(2.4, cam.zoom));
    }, { passive:false });

    // Drag interaction
    let dragging = false;
    let dragOff = { x:0, y:0 };
    function pos(ev){
      const r = canvas.getBoundingClientRect();
      return { x: ev.clientX - r.left, y: ev.clientY - r.top };
    }
    function hitMass(p){
      const r = 16 + 7 * Math.sqrt(+massEl.value);
      const dx = p.x - mass.sx, dy = p.y - mass.sy;
      return (dx*dx + dy*dy) <= r*r;
    }
    canvas.addEventListener("pointerdown", (ev) => {
      canvas.setPointerCapture(ev.pointerId);
      const p = pos(ev);
      if (hitMass(p)){
        dragging = true;
        dragOff.x = p.x - mass.sx;
        dragOff.y = p.y - mass.sy;
      }
    });
    canvas.addEventListener("pointermove", (ev) => {
      if (!dragging) return;
      const p = pos(ev);
      mass.sx = p.x - dragOff.x;
      mass.sy = p.y - dragOff.y;
    });
    canvas.addEventListener("pointerup", () => dragging = false);
    canvas.addEventListener("pointercancel", () => dragging = false);

    // --- 3D helpers ---
    function rotateY(v, a){
      const ca = Math.cos(a), sa = Math.sin(a);
      return { x: v.x * ca + v.z * sa, y: v.y, z: -v.x * sa + v.z * ca };
    }
    function rotateX(v, a){
      const ca = Math.cos(a), sa = Math.sin(a);
      return { x: v.x, y: v.y * ca - v.z * sa, z: v.y * sa + v.z * ca };
    }
    function project(v, w, h){
      const vz = v.z + 170;
      const d = cam.dist / cam.zoom;
      const s = d / (d + vz);
      return { x: w/2 + v.x * s, y: h/2 + v.y * s, s };
    }

    // Convert screen mass location -> world coords on the plane (approx)
    function screenToWorldOnPlane(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const worldScale = 1.0 / (Math.max(w,h) / 560);
      return {
        x: (mass.sx - w/2) * worldScale,
        y: (mass.sy - h/2) * worldScale
      };
    }

    // Funnel surface with fixed softening:
    // z = -(A*M) / sqrt(r^2 + a^2)
    // Then clamp to create a long throat like the reference.
    function surfaceZ(wx, wy){
      const M = +massEl.value;
      const A = +depthEl.value;

      const mpos = screenToWorldOnPlane();
      const dx = wx - mpos.x;
      const dy = wy - mpos.y;
      const r2 = dx*dx + dy*dy;

      let z = -(A * M) / Math.sqrt(r2 + SOFTENING*SOFTENING);

      // Long vertical “tube” feel like the black hole image
      const zMin = -3200;
      if (z < zMin) z = zMin;

      return z;
    }

    function draw(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);

      // Background
      ctx.fillStyle = "#061021";
      ctx.fillRect(0,0,w,h);

      // Subtle glow
      const glow = ctx.createRadialGradient(w*0.50, h*0.18, 30, w*0.50, h*0.18, Math.max(w,h)*0.9);
      glow.addColorStop(0, "rgba(120,190,255,0.10)");
      glow.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = glow;
      ctx.fillRect(0,0,w,h);

      // World mapping
      const worldScale = 1.0 / (Math.max(w,h) / 560);
      const spacingPx = +spacingEl.value;
      const spacingW = spacingPx * worldScale;

      // Wide “sheet” like reference
      const halfW = (w/2) * worldScale * 1.05;
      const halfH = (h/2) * worldScale * 0.70;

      // Sampling
      const stepPx = Math.max(6, Math.min(14, spacingPx / 3));
      const stepW = stepPx * worldScale;

      // Camera angles
      const yaw = cam.yaw;     // 0 => not slanted sideways
      const pitch = cam.pitch; // still tilted down to show the funnel

      // Frame outline (top plane border)
      function frameCorner(wx, wy){
        let v = { x: wx, y: wy, z: 0 };
        v = rotateY(v, yaw);
        v = rotateX(v, pitch);
        return project(v, w, h);
      }
      const p1 = frameCorner(-halfW, -halfH);
      const p2 = frameCorner( halfW, -halfH);
      const p3 = frameCorner( halfW,  halfH);
      const p4 = frameCorner(-halfW,  halfH);

      ctx.lineWidth = 5;
      ctx.strokeStyle = "rgba(60,160,255,0.85)";
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.lineTo(p4.x, p4.y);
      ctx.closePath();
      ctx.stroke();

      // Grid
      ctx.lineWidth = 1.5;
      const baseColor = "rgba(60,160,255,0.70)";
      const faintColor = "rgba(60,160,255,0.38)";

      function drawPolyline(pts, strokeStyle){
        if (pts.length < 2) return;
        ctx.strokeStyle = strokeStyle;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }

      for (let x = -halfW; x <= halfW; x += spacingW){
        const pts = [];
        for (let y = -halfH; y <= halfH; y += stepW){
          const z = surfaceZ(x, y);
          let v = { x, y, z };
          v = rotateY(v, yaw);
          v = rotateX(v, pitch);
          pts.push(project(v, w, h));
        }
        const stroke = (Math.abs(x) < spacingW*0.8) ? baseColor : faintColor;
        drawPolyline(pts, stroke);
      }

      for (let y = -halfH; y <= halfH; y += spacingW){
        const pts = [];
        for (let x = -halfW; x <= halfW; x += stepW){
          const z = surfaceZ(x, y);
          let v = { x, y, z };
          v = rotateY(v, yaw);
          v = rotateX(v, pitch);
          pts.push(project(v, w, h));
        }
        const stroke = (Math.abs(y) < spacingW*0.8) ? baseColor : faintColor;
        drawPolyline(pts, stroke);
      }

      // Mass marker (screen space)
      const M = +massEl.value;

      // Color shifts with mass (sun -> neutron -> black hole)
      function lerp(a,b,t){ return a + (b-a)*t; }
      function clamp01(t){ return Math.max(0, Math.min(1, t)); }

      const t0 = clamp01((M - 1.2) / (4.0 - 1.2));
      const t1 = clamp01((M - 4.0) / (12.0 - 4.0));

      let rr = lerp(255, 80, t0);
      let gg = lerp(190, 200, t0);
      let bb = lerp( 60, 255, t0);

      rr = lerp(rr, 10, t1);
      gg = lerp(gg, 10, t1);
      bb = lerp(bb, 10, t1);

      const radius = 16 + 7 * Math.sqrt(M);

      ctx.beginPath();
      ctx.arc(mass.sx, mass.sy, radius*2.0, 0, Math.PI*2);
      ctx.fillStyle = `rgba(${rr|0},${gg|0},${bb|0},0.10)`;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(mass.sx, mass.sy, radius, 0, Math.PI*2);
      ctx.fillStyle = `rgb(${rr|0},${gg|0},${bb|0})`;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(mass.sx, mass.sy, radius, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.font = "14px system-ui, sans-serif";
      ctx.fillStyle = "rgba(230,240,255,0.78)";
      ctx.fillText(`m = ${M.toFixed(2)}`, mass.sx + radius + 10, mass.sy + 5);

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>

