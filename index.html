<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spacetime Warp Diagram (Interactive)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0b0f1a;
      color: #e8eefc;
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
    }
    header {
      display: flex;
      gap: 14px;
      align-items: center;
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(15, 22, 40, 0.85);
      backdrop-filter: blur(10px);
      flex-wrap: wrap;
    }
    .group { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .btn {
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: inherit;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
    }
    .btn:hover { background: rgba(255,255,255,0.10); }
    .btn:active { transform: translateY(1px); }
    label {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      padding: 6px 10px;
      border-radius: 10px;
    }
    input[type="range"] { width: 160px; }
    .hint { opacity: 0.8; font-size: 0.92rem; }
    canvas { width: 100%; height: 100%; display: block; }
    .badge {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(123, 190, 255, 0.15);
      border: 1px solid rgba(123, 190, 255, 0.25);
      color: #bfe1ff;
    }
  </style>
</head>
<body>
  <header>
    <div class="group">
      <button class="btn" id="addMass">+ Add mass</button>
      <button class="btn" id="removeMass">– Remove mass</button>
      <button class="btn" id="reset">Reset</button>
      <span class="badge" id="massCount"></span>
    </div>

    <div class="group">
      <label title="Overall warping strength (think: how strong gravity is in this visualization)">
        Warp strength
        <input id="strength" type="range" min="0" max="200" value="90" />
        <span id="strengthVal"></span>
      </label>

      <label title="How fine the grid is">
        Grid spacing
        <input id="spacing" type="range" min="16" max="80" value="40" />
        <span id="spacingVal"></span>
      </label>

      <label title="Softening prevents infinite warps at the center; larger softening = smoother near masses">
        Softening
        <input id="softening" type="range" min="5" max="60" value="22" />
        <span id="softeningVal"></span>
      </label>
    </div>

    <div class="hint">
      Drag masses. Scroll/trackpad to zoom (optional). Click empty space to add a small mass.
    </div>
  </header>

  <canvas id="c"></canvas>

  <script>
    // ====== Canvas setup (HiDPI) ======
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }
    window.addEventListener('resize', resize);
    resize();

    // ====== Controls ======
    const strengthEl = document.getElementById('strength');
    const spacingEl = document.getElementById('spacing');
    const softeningEl = document.getElementById('softening');
    const strengthVal = document.getElementById('strengthVal');
    const spacingVal = document.getElementById('spacingVal');
    const softeningVal = document.getElementById('softeningVal');
    const massCount = document.getElementById('massCount');

    function updateLabels() {
      strengthVal.textContent = strengthEl.value;
      spacingVal.textContent = spacingEl.value + 'px';
      softeningVal.textContent = softeningEl.value + 'px';
      massCount.textContent = `${masses.length} mass${masses.length === 1 ? '' : 'es'}`;
    }
    [strengthEl, spacingEl, softeningEl].forEach(el => el.addEventListener('input', updateLabels));

    // ====== Simple "spacetime warp" model ======
    // We draw a grid of lines. Each grid point is displaced by a sum of mass-induced fields:
    // displacement vector at position p:
    //   d = Σ [ -k * m * (p - mi) / (|p - mi|^2 + s^2) ]
    // This is not GR, but it *looks* like curvature/warping and is interactive + stable.
    //
    // -k controls overall "warp strength"
    // s is softening to prevent singularities
    // m is a slider-per-mass value

    const masses = [];
    let zoom = 1;

    function resetMasses() {
      masses.length = 0;
      const w = canvas.clientWidth, h = canvas.clientHeight;
      masses.push({ x: w*0.38, y: h*0.52, m: 1.4 });
      masses.push({ x: w*0.65, y: h*0.45, m: 0.9 });
      updateLabels();
    }
    resetMasses();

    // Add/remove buttons
    document.getElementById('addMass').addEventListener('click', () => {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      masses.push({ x: w*(0.3+0.4*Math.random()), y: h*(0.3+0.4*Math.random()), m: 0.8+1.2*Math.random() });
      updateLabels();
    });
    document.getElementById('removeMass').addEventListener('click', () => {
      masses.pop();
      updateLabels();
    });
    document.getElementById('reset').addEventListener('click', () => {
      zoom = 1;
      resetMasses();
    });

    // ====== Interaction: drag masses + click to add ======
    let dragging = null;
    let dragOffset = { x: 0, y: 0 };

    function pointerPos(ev) {
      const rect = canvas.getBoundingClientRect();
      return { x: (ev.clientX - rect.left), y: (ev.clientY - rect.top) };
    }

    function hitTestMass(p) {
      // screen-space radius scales a bit with mass
      for (let i = masses.length - 1; i >= 0; i--) {
        const mm = masses[i];
        const r = 10 + 10 * Math.sqrt(mm.m);
        const dx = p.x - mm.x, dy = p.y - mm.y;
        if (dx*dx + dy*dy <= r*r) return i;
      }
      return -1;
    }

    canvas.addEventListener('pointerdown', (ev) => {
      canvas.setPointerCapture(ev.pointerId);
      const p = pointerPos(ev);
      const idx = hitTestMass(p);
      if (idx >= 0) {
        dragging = idx;
        dragOffset.x = p.x - masses[idx].x;
        dragOffset.y = p.y - masses[idx].y;
      } else {
        // Click empty space: add a small mass
        masses.push({ x: p.x, y: p.y, m: 0.7 });
        updateLabels();
      }
    });

    canvas.addEventListener('pointermove', (ev) => {
      if (dragging == null) return;
      const p = pointerPos(ev);
      masses[dragging].x = p.x - dragOffset.x;
      masses[dragging].y = p.y - dragOffset.y;
    });

    canvas.addEventListener('pointerup', () => { dragging = null; });
    canvas.addEventListener('pointercancel', () => { dragging = null; });

    // Optional zoom with wheel (keeps it simple: zoom the "field strength" feel + grid density visually)
    canvas.addEventListener('wheel', (ev) => {
      ev.preventDefault();
      const delta = Math.sign(ev.deltaY);
      zoom *= (delta > 0) ? 0.92 : 1.08;
      zoom = Math.max(0.55, Math.min(2.2, zoom));
    }, { passive: false });

    // ====== Rendering ======
    function warpPoint(x, y, k, s) {
      let dx = 0, dy = 0;
      for (const mm of masses) {
        const vx = x - mm.x;
        const vy = y - mm.y;
        const r2 = vx*vx + vy*vy + s*s;
        // Inverse-square-ish with softening; scaled by mass
        const f = -k * mm.m / r2;
        dx += f * vx;
        dy += f * vy;
      }
      return { x: x + dx, y: y + dy };
    }

    function drawGrid() {
      const w = canvas.clientWidth, h = canvas.clientHeight;

      // Controls -> parameters
      const baseSpacing = +spacingEl.value;
      const spacing = baseSpacing * zoom;
      const k = (+strengthEl.value) * 0.65 * zoom; // "warp strength"
      const s = +softeningEl.value;

      // Background
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#070b14';
      ctx.fillRect(0, 0, w, h);

      // A subtle radial glow
      const g = ctx.createRadialGradient(w*0.5, h*0.45, 20, w*0.5, h*0.45, Math.max(w,h)*0.75);
      g.addColorStop(0, 'rgba(85,150,255,0.10)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      // Grid style
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(170, 210, 255, 0.16)';

      // We sample each grid line as a polyline.
      // More samples => smoother but heavier. We'll adapt based on spacing.
      const step = Math.max(6, Math.min(16, spacing / 3));

      // Vertical lines
      for (let gx = Math.floor(0 / spacing) * spacing; gx <= w; gx += spacing) {
        ctx.beginPath();
        let first = true;
        for (let y = 0; y <= h; y += step) {
          const p = warpPoint(gx, y, k, s);
          if (first) { ctx.moveTo(p.x, p.y); first = false; }
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      // Horizontal lines
      for (let gy = Math.floor(0 / spacing) * spacing; gy <= h; gy += spacing) {
        ctx.beginPath();
        let first = true;
        for (let x = 0; x <= w; x += step) {
          const p = warpPoint(x, gy, k, s);
          if (first) { ctx.moveTo(p.x, p.y); first = false; }
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      // Draw masses on top
      for (let i = 0; i < masses.length; i++) {
        const mm = masses[i];
        const r = 10 + 10 * Math.sqrt(mm.m);

        // Accretion-like rings
        ctx.beginPath();
        ctx.arc(mm.x, mm.y, r*1.55, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(123, 190, 255, 0.18)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Core
        ctx.beginPath();
        ctx.arc(mm.x, mm.y, r, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(10, 14, 24, 0.95)';
        ctx.fill();

        // Rim highlight
        ctx.beginPath();
        ctx.arc(mm.x, mm.y, r, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(210, 235, 255, 0.40)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Label mass value
        ctx.font = '12px system-ui, sans-serif';
        ctx.fillStyle = 'rgba(225, 240, 255, 0.85)';
        ctx.fillText(`m=${mm.m.toFixed(2)}`, mm.x + r + 8, mm.y + 4);
      }

      // Title/legend
      ctx.font = '13px system-ui, sans-serif';
      ctx.fillStyle = 'rgba(230, 240, 255, 0.65)';
      ctx.fillText('Drag masses to see the grid (spacetime) warp', 12, 22);
    }

    // Animate (keeps it smooth while dragging)
    function tick() {
      drawGrid();
      requestAnimationFrame(tick);
    }
    updateLabels();
    tick();

    // ====== Extra: keyboard shortcuts to tweak selected mass ======
    // If you want per-mass control: hold Shift and scroll over a mass (simple)
    canvas.addEventListener('wheel', (ev) => {
      if (!ev.shiftKey) return;
      const p = pointerPos(ev);
      const idx = hitTestMass(p);
      if (idx < 0) return;
      ev.preventDefault();
      const dir = Math.sign(ev.deltaY);
      masses[idx].m *= (dir > 0) ? 0.92 : 1.08;
      masses[idx].m = Math.max(0.2, Math.min(6, masses[idx].m));
    }, { passive: false });
  </script>
</body>
</html>
