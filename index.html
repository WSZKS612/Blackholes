<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spacetime Warp</title>
  <style>
    :root { color-scheme: dark; }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      height:100vh;
      background:#000;
      color:#eaf2ff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow:hidden;
    }

    /* Canvas fills screen */
    canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
    }

    /* Minimal controls: sliders + reset only */
    .ui{
      position:fixed;
      left:50%;
      bottom:22px;
      transform:translateX(-50%);
      width:min(780px, calc(100vw - 28px));
      z-index:10;
      pointer-events:auto;
      display:flex;
      align-items:center;
      gap:12px;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.30);
      backdrop-filter: blur(10px);
    }

    .sliders{
      flex:1;
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px;
      min-width:0;
    }

    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:0;
      font-size:11px;
      letter-spacing:0.14em;
      text-transform:uppercase;
      opacity:0.86;
    }
    input[type="range"]{
      width:100%;
      accent-color:#7dc3ff;
    }
    .vals{
      display:flex;
      justify-content:space-between;
      font-size:11px;
      opacity:0.72;
      letter-spacing:0.08em;
    }

    .btn{
      width:52px;
      height:52px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.25);
      color:inherit;
      cursor:pointer;
      display:grid;
      place-items:center;
      font-size:20px;
    }
    .btn:hover{ background:rgba(255,255,255,0.06); }

    @media (max-width: 720px){
      .sliders{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .ui{ bottom:14px; }
      .btn{ width:50px; height:50px; }
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>

<div class="ui" aria-label="Simulation controls">
  <div class="sliders">
    <label>
      Mass
      <input id="mass" type="range" min="0.2" max="12" step="0.01" value="2.5" />
      <div class="vals"><span id="massVal">2.50</span><span>m</span></div>
    </label>

    <label>
      Warp
      <input id="strength" type="range" min="30" max="500" step="1" value="180" />
      <div class="vals"><span id="strengthVal">180</span><span>k</span></div>
    </label>

    <label>
      Softening
      <input id="softening" type="range" min="6" max="70" step="1" value="26" />
      <div class="vals"><span id="softeningVal">26</span><span>px</span></div>
    </label>

    <label>
      Grid
      <input id="spacing" type="range" min="18" max="70" step="1" value="34" />
      <div class="vals"><span id="spacingVal">34</span><span>px</span></div>
    </label>
  </div>

  <button class="btn" id="reset" title="Reset view">‚ü≤</button>
</div>

<script>
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // HiDPI
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const r = canvas.getBoundingClientRect();
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  // UI
  const massEl = document.getElementById("mass");
  const strengthEl = document.getElementById("strength");
  const softeningEl = document.getElementById("softening");
  const spacingEl = document.getElementById("spacing");

  const massVal = document.getElementById("massVal");
  const strengthVal = document.getElementById("strengthVal");
  const softeningVal = document.getElementById("softeningVal");
  const spacingVal = document.getElementById("spacingVal");

  function updateLabels(){
    massVal.textContent = (+massEl.value).toFixed(2);
    strengthVal.textContent = strengthEl.value;
    softeningVal.textContent = softeningEl.value;
    spacingVal.textContent = spacingEl.value;
  }
  [massEl, strengthEl, softeningEl, spacingEl].forEach(el => el.addEventListener("input", updateLabels));
  updateLabels();

  // One draggable mass
  const mass = { x: 0, y: 0 };

  function resetMassPos(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    mass.x = w * 0.42;
    mass.y = h * 0.46;
  }
  resetMassPos();

  // Camera: angled toward viewer (like your reference), and wide plane fills screen
  let cam = {
    yaw: 0.04,
    pitch: 0.72,  // tilt toward viewer
    zoom: 1.0,
    dist: 980
  };

  document.getElementById("reset").addEventListener("click", () => {
    cam.yaw = 0.04;
    cam.pitch = 0.72;
    cam.zoom = 1.0;
    resetMassPos();
  });

  // Drag to move mass OR rotate plane (drag empty space)
  let pointerDown = false;
  let draggingMass = false;
  let last = { x: 0, y: 0 };
  let dragOffset = { x: 0, y: 0 };

  function pos(ev){
    const r = canvas.getBoundingClientRect();
    return { x: ev.clientX - r.left, y: ev.clientY - r.top };
  }
  function hitMass(p){
    const r = 16 + 7 * Math.sqrt(+massEl.value);
    const dx = p.x - mass.x, dy = p.y - mass.y;
    return (dx*dx + dy*dy) <= r*r;
  }

  canvas.addEventListener("pointerdown", (ev) => {
    canvas.setPointerCapture(ev.pointerId);
    pointerDown = true;
    const p = pos(ev);
    last = p;
    if (hitMass(p)){
      draggingMass = true;
      dragOffset.x = p.x - mass.x;
      dragOffset.y = p.y - mass.y;
    } else {
      draggingMass = false;
    }
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (!pointerDown) return;
    const p = pos(ev);
    const dx = p.x - last.x;
    const dy = p.y - last.y;
    last = p;

    if (draggingMass){
      mass.x = p.x - dragOffset.x;
      mass.y = p.y - dragOffset.y;
    } else {
      cam.yaw += dx * 0.0048;
      cam.pitch += dy * 0.0048;
      cam.pitch = Math.max(0.52, Math.min(1.05, cam.pitch));
    }
  });

  canvas.addEventListener("pointerup", () => { pointerDown = false; draggingMass = false; });
  canvas.addEventListener("pointercancel", () => { pointerDown = false; draggingMass = false; });

  // Wheel zoom
  canvas.addEventListener("wheel", (ev) => {
    ev.preventDefault();
    const dir = Math.sign(ev.deltaY);
    cam.zoom *= (dir > 0) ? 0.92 : 1.08;
    cam.zoom = Math.max(0.55, Math.min(2.6, cam.zoom));
  }, { passive:false });

  // --- 3D math ---
  function rotateY(v, a){
    const ca = Math.cos(a), sa = Math.sin(a);
    return { x: v.x * ca + v.z * sa, y: v.y, z: -v.x * sa + v.z * ca };
  }
  function rotateX(v, a){
    const ca = Math.cos(a), sa = Math.sin(a);
    return { x: v.x, y: v.y * ca - v.z * sa, z: v.y * sa + v.z * ca };
  }
  function project(v, w, h){
    const vz = v.z + 290;          // lift the sheet so it reads across whole screen
    const d = cam.dist / cam.zoom;
    const s = d / (d + vz);
    return { x: w/2 + v.x * s, y: h/2 + v.y * s, s };
  }

  // Warping with softening:
  // z = -k * m / sqrt(r^2 + a^2)
  function sheetZ(wx, wy){
    const k = +strengthEl.value;
    const m = +massEl.value;

    const w = canvas.clientWidth, h = canvas.clientHeight;

    // IMPORTANT: choose scale so the plane fills the *entire* screen (like your reference)
    const worldScale = 1.0 / (Math.max(w,h) / 820);

    // softening in world units
    const a = (+softeningEl.value) * worldScale;

    // mass position in world coords
    const mx = (mass.x - w/2) * worldScale;
    const my = (mass.y - h/2) * worldScale;

    const dx = wx - mx;
    const dy = wy - my;
    const r2 = dx*dx + dy*dy;

    let z = -(k * m) / Math.sqrt(r2 + a*a);

    // Clamp so it never becomes an absurd tube, while still allowing strong warping
    const zMin = -1600;
    if (z < zMin) z = zMin;

    return z;
  }

  // Starfield (subtle)
  function drawStars(w,h){
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    for (let i=0;i<160;i++){
      const x = (i*137) % w;
      const y = (i*227) % h;
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function draw(){
    const w = canvas.clientWidth, h = canvas.clientHeight;

    // background
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,w,h);
    drawStars(w,h);

    const spacingPx = +spacingEl.value;
    const stepPx = Math.max(6, Math.min(14, spacingPx / 3));

    const worldScale = 1.0 / (Math.max(w,h) / 820);
    const spacingW = spacingPx * worldScale;
    const stepW = stepPx * worldScale;

    // Plane extents: make it bigger than the view frustum so it fills the whole screen
    const halfW = (w/2) * worldScale * 2.05;
    const halfH = (h/2) * worldScale * 1.55;

    const yaw = cam.yaw;
    const pitch = cam.pitch;

    ctx.lineWidth = 1.15;

    function strokeLine(pts, alpha){
      if (pts.length < 2) return;
      ctx.strokeStyle = `rgba(190,190,190,${alpha})`;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }

    // Vertical grid lines
    for (let gx = -halfW; gx <= halfW; gx += spacingW){
      const pts = [];
      for (let y = -halfH; y <= halfH; y += stepW){
        const z = sheetZ(gx, y);
        let v = { x: gx, y, z };
        v = rotateY(v, yaw);
        v = rotateX(v, pitch);
        pts.push(project(v, w, h));
      }
      const mid = pts[(pts.length/2)|0];
      const alpha = 0.10 + 0.48 * Math.max(0, Math.min(1, mid.s));
      strokeLine(pts, alpha);
    }

    // Horizontal grid lines
    for (let gy = -halfH; gy <= halfH; gy += spacingW){
      const pts = [];
      for (let x = -halfW; x <= halfW; x += stepW){
        const z = sheetZ(x, gy);
        let v = { x, y: gy, z };
        v = rotateY(v, yaw);
        v = rotateX(v, pitch);
        pts.push(project(v, w, h));
      }
      const mid = pts[(pts.length/2)|0];
      const alpha = 0.08 + 0.44 * Math.max(0, Math.min(1, mid.s));
      strokeLine(pts, alpha);
    }

    // Mass marker
    const M = +massEl.value;
    const radius = 18 + 7 * Math.sqrt(M);

    // glow
    ctx.beginPath();
    ctx.arc(mass.x, mass.y, radius*2.4, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,230,170,0.10)";
    ctx.fill();

    // body
    ctx.beginPath();
    ctx.arc(mass.x, mass.y, radius, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,230,190,0.95)";
    ctx.fill();

    // rim
    ctx.beginPath();
    ctx.arc(mass.x, mass.y, radius, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,255,255,0.32)";
    ctx.lineWidth = 2;
    ctx.stroke();

    requestAnimationFrame(draw);
  }

  draw();
</script>
</body>
</html>
