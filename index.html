<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Spacetime Warp (Interactive)</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0;
      height:100vh;
      display:grid;
      grid-template-rows:auto 1fr;
      background:#02040a;
      color:#eaf2ff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    header{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
      padding:10px 12px;
      background:rgba(10,16,30,0.82);
      border-bottom:1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
    }
    .group{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    label{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.05);
    }
    input[type="range"]{ width:180px; }
    .btn{
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      color:inherit;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{ background:rgba(255,255,255,0.10); }
    canvas{ width:100%; height:100%; display:block; }
    .badge{
      font-size:12px;
      padding:3px 8px;
      border-radius:999px;
      background:rgba(123,190,255,0.12);
      border:1px solid rgba(123,190,255,0.25);
      color:#cfe8ff;
    }
    .hint{ opacity:0.85; font-size:0.92rem; }
  </style>
</head>
<body>
  <header>
    <div class="group">
      <span class="badge">Drag the mass • Drag empty space to rotate • Scroll to zoom</span>
    </div>

    <div class="group">
      <label title="Change the mass (bigger = deeper 'well')">
        Mass
        <input id="mass" type="range" min="0.2" max="12" step="0.01" value="2.5" />
        <span id="massVal"></span>
      </label>

      <label title="Overall warping strength (visual scale)">
        Warp strength
        <input id="strength" type="range" min="30" max="500" step="1" value="180" />
        <span id="strengthVal"></span>
      </label>

      <label title="Softening prevents an infinite spike at the center; larger = smoother (less extreme) near the mass">
        Softening
        <input id="softening" type="range" min="6" max="70" step="1" value="26" />
        <span id="softeningVal"></span>
      </label>

      <label title="Grid spacing (bigger = fewer lines, faster)">
        Grid
        <input id="spacing" type="range" min="18" max="70" step="1" value="34" />
        <span id="spacingVal"></span>
      </label>

      <button class="btn" id="reset">Reset view</button>
    </div>

    <div class="hint">Plane fills the screen; tilt it toward you and adjust softening to control how extreme the dent becomes.</div>
  </header>

  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    // HiDPI
    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const r = canvas.getBoundingClientRect();
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }
    window.addEventListener("resize", resize);
    resize();

    // UI
    const massEl = document.getElementById("mass");
    const strengthEl = document.getElementById("strength");
    const softeningEl = document.getElementById("softening");
    const spacingEl = document.getElementById("spacing");
    const massVal = document.getElementById("massVal");
    const strengthVal = document.getElementById("strengthVal");
    const softeningVal = document.getElementById("softeningVal");
    const spacingVal = document.getElementById("spacingVal");

    function updateLabels(){
      massVal.textContent = (+massEl.value).toFixed(2);
      strengthVal.textContent = strengthEl.value;
      softeningVal.textContent = softeningEl.value + "px";
      spacingVal.textContent = spacingEl.value + "px";
    }
    [massEl, strengthEl, softeningEl, spacingEl].forEach(el => el.addEventListener("input", updateLabels));
    updateLabels();

    // One mass (draggable)
    const mass = { x: 0, y: 0, m: +massEl.value };

    function resetMassPos(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      mass.x = w * 0.34;
      mass.y = h * 0.44;
    }
    resetMassPos();

    // Camera: tilt toward viewer; allow slight rotation with drag-empty-space
    let cam = {
      yaw: 0.18,      // slight sideways rotation
      pitch: 0.95,    // tilt toward viewer (lower = more toward viewer)
      zoom: 1.0,
      dist: 760
    };

    document.getElementById("reset").addEventListener("click", () => {
      cam.yaw = 0.18;
      cam.pitch = 0.95;
      cam.zoom = 1.0;
      resetMassPos();
    });

    // Interaction: drag mass OR rotate
    let pointerDown = false;
    let draggingMass = false;
    let last = { x: 0, y: 0 };
    let dragOffset = { x: 0, y: 0 };

    function pos(ev){
      const r = canvas.getBoundingClientRect();
      return { x: ev.clientX - r.left, y: ev.clientY - r.top };
    }

    function hitMass(p){
      const r = 16 + 7 * Math.sqrt(+massEl.value);
      const dx = p.x - mass.x, dy = p.y - mass.y;
      return (dx*dx + dy*dy) <= r*r;
    }

    canvas.addEventListener("pointerdown", (ev) => {
      canvas.setPointerCapture(ev.pointerId);
      pointerDown = true;
      const p = pos(ev);
      last = p;
      if (hitMass(p)){
        draggingMass = true;
        dragOffset.x = p.x - mass.x;
        dragOffset.y = p.y - mass.y;
      } else {
        draggingMass = false; // rotate
      }
    });

    canvas.addEventListener("pointermove", (ev) => {
      if (!pointerDown) return;
      const p = pos(ev);
      const dx = p.x - last.x;
      const dy = p.y - last.y;
      last = p;

      if (draggingMass){
        mass.x = p.x - dragOffset.x;
        mass.y = p.y - dragOffset.y;
      } else {
        cam.yaw += dx * 0.006;
        cam.pitch += dy * 0.006;
        cam.pitch = Math.max(0.50, Math.min(1.25, cam.pitch)); // keep sensible tilt
      }
    });

    canvas.addEventListener("pointerup", () => { pointerDown = false; draggingMass = false; });
    canvas.addEventListener("pointercancel", () => { pointerDown = false; draggingMass = false; });

    // Zoom
    canvas.addEventListener("wheel", (ev) => {
      ev.preventDefault();
      const dir = Math.sign(ev.deltaY);
      cam.zoom *= (dir > 0) ? 0.92 : 1.08;
      cam.zoom = Math.max(0.55, Math.min(2.4, cam.zoom));
    }, { passive:false });

    // --- 3D math ---
    // World coords:
    // X: left/right, Y: forward/back, Z: up (sheet dips to negative Z).
    function rotateY(v, a){
      const ca = Math.cos(a), sa = Math.sin(a);
      return { x: v.x * ca + v.z * sa, y: v.y, z: -v.x * sa + v.z * ca };
    }
    function rotateX(v, a){
      const ca = Math.cos(a), sa = Math.sin(a);
      return { x: v.x, y: v.y * ca - v.z * sa, z: v.y * sa + v.z * ca };
    }

    function project(v, w, h){
      // Perspective projection
      const vz = v.z + 240; // lift sheet so you see both surface + dent
      const d = cam.dist / cam.zoom;
      const s = d / (d + vz);
      return { x: w/2 + v.x * s, y: h/2 + v.y * s, s };
    }

    // Surface displacement with softening (adjustable) like earlier:
    // z = -A * m / sqrt(r^2 + soft^2)
    function sheetZ(wx, wy){
      const softPx = +softeningEl.value;
      const A = +strengthEl.value;
      const m = +massEl.value;

      const w = canvas.clientWidth, h = canvas.clientHeight;
      const worldScale = 1.0 / (Math.max(w,h) / 620); // keep plane wide
      const soft = softPx * worldScale;

      // mass position in world coords
      const mx = (mass.x - w/2) * worldScale;
      const my = (mass.y - h/2) * worldScale;

      const dx = wx - mx;
      const dy = wy - my;
      const r2 = dx*dx + dy*dy;

      // main "dent"
      let z = -(A * m) / Math.sqrt(r2 + soft*soft);

      // clamp to avoid insane extreme tubes at high mass
      const zMin = -1800;
      if (z < zMin) z = zMin;

      return z;
    }

    // Simple starfield dots
    function drawStars(w,h){
      ctx.fillStyle = "rgba(255,255,255,0.12)";
      for (let i=0;i<80;i++){
        const x = (i*97) % w;
        const y = (i*193) % h;
        ctx.fillRect(x, y, 1, 1);
      }
    }

    function draw(){
      const w = canvas.clientWidth, h = canvas.clientHeight;

      // Background
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, w, h);
      drawStars(w,h);

      // World scaling: choose extents so plane fills full width like the reference
      const worldScale = 1.0 / (Math.max(w,h) / 620);

      // Grid spacing in world units
      const spacingPx = +spacingEl.value;
      const spacingW = spacingPx * worldScale;

      // Full-width plane: extend a bit beyond edges to ensure it fills screen
      const halfW = (w/2) * worldScale * 1.35; // wider than screen
      const halfH = (h/2) * worldScale * 0.95; // fairly deep

      // Sampling
      const stepPx = Math.max(6, Math.min(14, spacingPx / 3));
      const stepW = stepPx * worldScale;

      const yaw = cam.yaw;
      const pitch = cam.pitch;

      // Grid drawing
      ctx.lineWidth = 1.25;
      ctx.strokeStyle = "rgba(200,200,200,0.45)";

      function drawPolyline(points, alpha){
        if (points.length < 2) return;
        ctx.strokeStyle = `rgba(200,200,200,${alpha})`;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.stroke();
      }

      // Vertical lines
      for (let gx = -halfW; gx <= halfW; gx += spacingW){
        const pts = [];
        for (let y = -halfH; y <= halfH; y += stepW){
          const z = sheetZ(gx, y);
          let v = { x: gx, y, z };
          v = rotateY(v, yaw);
          v = rotateX(v, pitch);
          const p = project(v, w, h);
          pts.push(p);
        }
        const mid = pts[(pts.length/2)|0];
        const alpha = 0.20 + 0.35 * Math.max(0, Math.min(1, mid.s));
        drawPolyline(pts, alpha);
      }

      // Horizontal lines
      for (let gy = -halfH; gy <= halfH; gy += spacingW){
        const pts = [];
        for (let x = -halfW; x <= halfW; x += stepW){
          const z = sheetZ(x, gy);
          let v = { x, y: gy, z };
          v = rotateY(v, yaw);
          v = rotateX(v, pitch);
          const p = project(v, w, h);
          pts.push(p);
        }
        const mid = pts[(pts.length/2)|0];
        const alpha = 0.18 + 0.32 * Math.max(0, Math.min(1, mid.s));
        drawPolyline(pts, alpha);
      }

      // Mass marker (screen space)
      const M = +massEl.value;
      const radius = 18 + 7 * Math.sqrt(M);

      // glow
      ctx.beginPath();
      ctx.arc(mass.x, mass.y, radius*2.2, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,230,170,0.12)";
      ctx.fill();

      // body
      ctx.beginPath();
      ctx.arc(mass.x, mass.y, radius, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,230,190,0.95)";
      ctx.fill();

      // outline
      ctx.beginPath();
      ctx.arc(mass.x, mass.y, radius, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // label
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillStyle = "rgba(230,240,255,0.80)";
      ctx.fillText(`m = ${M.toFixed(2)}`, mass.x + radius + 10, mass.y + 5);

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
